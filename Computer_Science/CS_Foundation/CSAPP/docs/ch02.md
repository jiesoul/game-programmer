## 信息的表示和使用

现代计算机存储和执行的信息表示为二进制。

无符号编码基于传统的二进制信号，表示大于等于0的数字。补码(Two’s-complement)编码是最常用的表示有符号整数。浮点数是基于以2为底的信号表示实数。计算机实现算术操作像加减乘等这些不同的表示，相似于整数和实数的正常操作。

计算机使用有限的字节数编码数字，并且当结果太大时会溢出。这会导致奇怪的问题。

浮点数计算完全不同于数学上的专有属性。一个集合的正数乘积永远是正的，溢出表示为 +无穷大。浮点数只能表示为有限的精度。

### 信息存储
许多计算机使用8比特或字节表示最小的内存可用地址单元。一个机器级的程序看待内存为一个巨大的字节数组，
叫做虚拟内存。内存的每一字节通过一个唯一数字标识，作为它的地址，所有的可能的址叫做虚拟地址空间。通过名字可知，虚拟内存空间只是一个想象中的概念。真实的实现使用动态随机访问内存(DRAM)组合,闪存、硬盘、特殊硬件和操作系统软件表示程序看起来都像是一大块字节数组。

#### 十六进制记法

一个字节由8个比特组成，在二进制中它的值区间为$00000000_2$到$11111111_2$。表示为十进制为从$0_10$到$255_10$。都二进制太啰嗦，十进制转换啰嗦，代替的，我们一般表示比特模式使用16进制。十六进制使用0到9的数字和A到F的字母表示16个可能的值，从 $00_{16}$ 到$FF_{16}$。C 中使用前缀 0X 或0x 表示数字是十六进制的。A 到 F 的字母大小写都可。

#### 数据大小

每个计算机都一个字长(word size)，表示普通指针数据的大小。因为一个虚拟地址使用字长编码，最重要的系统参数虚拟地址空间的最大长度是由字长决定的。机器是 $w-bit$ 字长，虚拟地址空间的区间是从 0 到 $2^w-1$，给程序处理的最多 $2^w$ 个比特。

计算机和编译器支持多种数据格式使用不同的路径去编码，像整数和浮点数，众所周知有不同的长度。

#### 寻址和字节顺序

对于需要多个字节的程序对象，我们必须确定两个约定：对象的地址会是什么，和怎么样在内存中排列字节。实际上所有机器，一个多字节对象被储存为一个连续的字节序列，对象的地址是使用的字节的最小地址。

一个对象的字节排列，有两个常用的约定。小端法(最小的是第一个存储)和大端法(最大的第一个存储)。

#### 布尔代数

布尔代数是二值的。布尔操作 ~ 相当于逻辑操作 NOT， & 相当于 AND，| 相当于 OR， ^ 相当于异或。

我们扩展 4 个布尔操作到操作比特向量，0个字符串和一个固定的长度 w。

#### C 中位级操作

布尔操作精确的被使用在C 中，| 对OR， & 对 AND， ~ 对 NOT，^ 对 异或。这此操作可以应用在任何完整的数据类型。

#### C 中的逻辑操作

C 也提供逻辑操作的集合，|| 、&& 和 ！，分别表示逻辑 OR、AND 和 NOT。

#### C 中的位移操作

C 提供向左和右的位移看你咯。 x << k 表示 x 向左移动 k 个位，删除最大的位且用 0 填充右边的位。

有相对的右移操作写作 x >> k，但是它有微小的差别。通常，机器支持两种右移方式：

* 逻辑。逻辑右移在左边使用 0 填充。
* 算术。算术右移填充左边使用最大位。

### 整数表示

两种不同的编码整数：一种是非负数字，一种是负数、零和正数。

#### 整数数据类型

C 支持多种整数数据类型--一种表示整数的有限区间。类型区间都有 32位和64位区分。每个类型能指定一个大小关键字 char， short， long。

区间并不是对称的因为0 的关系。

#### 补码编码

最常用的用来表示负数值。最大的位表示符号位。符号位为1时表示值是负的，当设置为0时，表示值是非负的。

$$B2T_W(\vec x) = -x_{w-1}2^{w-1} + \sum^{w-2}_{i=0}x_i2^i$$

$$B2T_4([0001]) = -0 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 0 + 0 + 0 + 1 = 1$$ 

$$B2T_4([111]) = -1 \cdot 2^3 + 1 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -8 + 4 + 2 + 1 = -1$$

 #### 有符号无符号之间转换

大多 C 实现处理转换使用相同的字长--数字值可能改变，但是比特模式不变。

#### C 中有符号无符号对比

几乎所有的机器都使用二补码。通常数字默认使用有符号的。

#### 扩展数字的比特表示

转换一个无符号数字到更大的数据类型，简单的添加 0 表示。这个操作叫做零扩展，有下面的原则：

* 无符号数通过 0 扩展。比特向量 $\vec u = [u_{w-1},u_{w-2},...u_0]$ 宽度为 w ， 且 $\vec u' = [0,...0,u_{w-1},u_{w-2},...u0]$ 宽度为 $u'$， 当 $w' > w$ 时，$B2U_w(\vec u) = B2U_{w'}(\vec u')$
* 转换二被码数字到更大的数据类型，规则是执行符号扩展，添加最高位比特去表示。比特向量 $\vec x = [x_{w-},x_{w-2},...,x_0]$ 宽度为 w，向量 $\vec x' = [x_{w-1},...,x_{w-1},x_{w-1},x_{w-2},...,x_0]$ 宽度为 $W'$,则 $B2T_w(\vec x) = B2T_w'(\vec x')$ 

#### 截断数字

* 截断无符号数。比特向量 $\vec x = [x_{w-1},x_{w-2},...,x_0]$ , 截断 k 比特的结果 $\vec x' = [x_{k-1},x_{k-2},...,x_0]$ , 让 $x = B2U_w(\vec x)$ 且 $x' = B2U_k(\vec x')$ ,则 $x' = x\mod2^k$ 
* 截断二补码数字。$\vec x = [x_{w-1},x_{w-2},...,x_0]$, 截断 k 比特的结果 $\vec x' = [x_{k-1},x_{k-2},...x_0]$，让$x = B2T_w(\vec x)$ 且 $x' = B2T_k(\vec x')$ 则 $x' = U2T_k(x\mod 2^k)$ 。

#### 无符号有符号数对比建议

隐式转换可能会导致问题。

### 整数计算

许多新手会对两个正数加起来变成负数感到惊奇。x < y 和 x -y < 0  有不同的结果。理解计算的细微差别能帮助编程者写出更可靠的代码。

#### 无符号加法

如果两个非负整数 x，y，它们的取值区间为 $0 \leq x,y \lt 2^w $ .它们每个值都能被表示为 w 比特的符号数字。如果我们计算它们的和，我们将可能得到区间 $0 \leq x + y \leq 2^{w+1}-2$ 。表示这个和可能需要 w +1 比特。字长膨胀意味着我们不能全部表示算术的结果。有些编程语言像 Lisp 支持任意大小的计算(只有内存限制).更平常的，编程语言支持固定大小计算，并且像加法或乘法可能不同于它们的整数运算。

* 无符号加法。对于 x 和 y , $0 \leq x,y < 2^w$ ：$$x+^u_w y = \left\{ \begin{matrix}x + y,& x+y<2^w & Normal \\ x +y - 2^w, & 2^W \leq x +y < 2^{w+1} & Overflow \end{matrix} \right.$$
* 检测无符号加法溢出。对于 x 和 y ，区间为 $0 \leq x,y \leq UMax_w,let\space s = x +^u_wy$ ,则如果且只有 $s < x$,s 的计算溢出。
* 无符号取反。对你任意 x 区间$0 \leq x < 2^w$，它的 w 比特无符号取反 $-^u_wx$ 是： $$-^u_w=\{\begin{matrix} x, & x =0 \\ 2^w-x, & x > 0 \end{matrix}$$ 

#### 二补码加法

对于二补码加法，当结果太小或太大时我们必须决定用什么表示。

* 二补码加法。对于整数值 x 和 y，区间为 $-2^{w-1} \leq x, y \leq 2^{w-1}-1$ : $$x+^t_wy = \left\{ \begin{matrix} x + y - 2^w, & 2^{w-1} \leq x + y & Positive overflow \\ x + y, & -2^{w-1} \leq x + y < 2^{w-1} & Normal \\  x + y + 2^w, & x + y < -2^{w-1} & Negative overflow \end{matrix} \right.$$
* 检测二补码加法溢出。对于 x 和 y ，区间 $TMin_w \leq x,y \leq TMax_w, let \space s \doteq x+^t_wy$,如果 x >0 且 y > 0 但是 $s \leq 0$ s 的计算结果正溢出，仅当 x < 0 且 y < 0 但是 $s \geq 0$ 时，结果负溢出。

#### 二补码取反

* 二补码取反。 x 在区间 $TMin_w \leq x \leq TMax_w$,它的二补码取反 $-^t_wx$ 是： $-^t_wx = \left\{ \begin{matrix} TMin_w, & x = TMin_w \\ -x, & x > TMin_w \end{matrix} \right.$

