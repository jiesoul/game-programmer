## 程序的机器级表示

计算机执行机器码，字节序列编码为低级操作：操作数据，管理内存，读写磁盘上的数据，在网络上互联。编译器通过一系列步骤生成机器码，基于编程语言的规则，目标机器的指令集，且依照对应的操作系统的要求。 gcc C 编译器生成汇编代码的形式，程序中单独指令的文本化表示。GCC 然后调用汇编器和链接器从汇编代码生成可执行的机器码。

高级语言像 C Java 屏蔽胃我们程序的机器级明细。作为对比，当写汇编代码时程序员必须指定程序用来承担计算的低级指令。

### 程序编码

程序文件 p1.c 和 p2.c

```bash
gcc -Og -o p p1.c p2.c
```

命令 gcc 表示 gcc C 编译器。这是 Linux 默认编译器，可以简单的用 cc 代替。选项 -Og 指示编译器的优化级别。越高的级别机器码与源代码之间的关系越难理解。-Og 的优化级别作为学习工具。更高级的优化级别会导致更好性能。

gcc 编译通过一系列步骤转换源代码到可执行代码。首先，C 预处理器展开源代码中的 #include 和 #define 。第二步编译器生成汇编代码文件 p1.s 和 p2.s 。接下来汇编器转换汇编代码为二进制目标谁的 p1.o 和 p2.o 。目标代码是机器码中的一种形式，目标代码包含所有指令的二进制表示，但是里面没有全局值的地址。最后链接器使用库函数合并两个目标文件并生成最终的可执行代码文件。可执行代码文件是机器码的别一种形式，它是被处理器执行的精确代码。

#### 机器级代码

两个尤其重要的机器级编程。首先，机器级程序的格式和行为通过指令集(ISA)定义，定义了处理器状态，指令的格式和它们中的每个指令在状态上的有效。许多 ISA 包括 x86-64，解释了程序的行为是指令按序执行，一个指令完成下一个开始。处理器硬件经过精心设计可并发执行多个指令，而且能保护行为匹配 ISA 的序列操作。第二，机器级使用虚拟地址作为内存地址，提供一个看上去非常巨大的字节数组的内存模型。

编译器在全部编译序列中做大部分的工作，转换由 C 提供的相关抽象执行模型的程序表示到处理器执行的非常简单的指令。汇编代码非常接近机器码。主要特性就是它有许多可读的文件形式，相比于机器码的二进制形式。能理解汇编代码和和它相关的原始 C 代码是理解计算机怎样执行程序的关键步骤。

x86-64 机器码非常不同于原始 C 代码。有部分处理器是可见的但是 C 程序员通常是隐藏：

* 程序计数器(program counter，通常叫 PC，在 x-86-64 中调用 %rip)表示下个被执行的指令在内存中的地址。
* 整数寄存器(integer register file) 包含 16 个已命名的储存 64 比特值的位置。这些寄存器能地址(对应 C 中的指针)或整数数据。一些寄存器可用来跟踪程序状态的关键部分，当其它被用来持有临时数据，像参数和一个程序的局部变量，数据的返回值时。
* 状态代码寄存器(condition code registers) 持有关于最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中状态的改变，像实现 if 和 while 语句。
* 一个向量寄存器集合，每个都能持有一个或多个整数或浮点数值。

尽管 C 提供了不同数据类型对象能被声明和分配在内存中的模型，但是机器码显示内存就是简单的一个巨大的比特址址级数组。C 中的合计类型像数组和结构在机器码中表示为字节的连接集合。对于每个可伸缩数据类型，汇编代码不区分有无符号，不同类型的指针，甚至指针和整数。

程序内存包含程序的可执行机器码，操作系统提供的一些必要信息，管理过程调用和返回的运行时栈，用户分配的内存块。程序内存通过虚拟地址定位。在任意给定的时间，只有有限的虚拟地址是有效的。

单一机器指令仅执行非常基本的操作。比如它可能在寄存器中把两个数加起来，在内存和寄存器中传输数据，或条件分支去一个新的地址。编译器必须一系列指令，实现像算术表达式计算，循环，或过程调用和返回的程序构造。

### 数据格式

在 16 比特扩展到 32 比特期间， Inter 使用 word 表示一个 16 比特数据，基于这个 32 比特表示为 double words， 64 比特为 quad words。

### 处理信息

#### 操作数说明

许多指令有一个或多个操作数表示在执行一个操作中使用的源值和产生的结果放在哪里。源值可以为常量或从寄存器或内存中读取的值，结果能储存在寄存器或内存中。不同的操作数能分成三类。第一类，直接的，是常量值。第二，寄存器表示寄存器的内容。第三类是内存引用，我们访问一些内存定位来计算地址，一般叫做有效地址。

#### 数据移动指令 mov

许多重度使用的指令是复制数据到另一个地址。有许多不同数据移动指令，不同之处在它们的源和类型上，它们执行什么转换，和可能其它的副作用。

#### 压入和弹出栈数据

栈是过程调用不可缺少的角色。从后端来说，栈是值能被添加删除但是依照后进先出的规则的数据结构。添加数据到栈通过 push，删除数据通过 pop，弹出的值一定是刚被压入的值。值能被实现为数组，我们能从数组的末端插入和移除元素。这个末端叫做栈的顶(top)。栈向下生长，栈顶是所有栈元素中最小的地址，栈指针 %rsp 持有栈顶元素的地址。

