## 计算机系统概览

计算机系统由硬件和系统软件和一起运行在它之上的应用软件组成。

这个课程我们将使用C 编程语言，而大部分的的编程学习从 hello world 程序开始：

```c
#include <stdio.h>

int main()
{
  printf("hello, world\n");
  return 0;
}
```

### 信息就是比特加上下文

使用编辑器创建的 hello 程序保存在文本文件 hello.c 中，像这种文件被称为源程序或源文件。

### 程序被其它程序转换成不同的形式。

```bash
gcc -o hello hello.c
```

Unix 系统中，从源文件到目标文件由编译器执行：
* 预处理阶段。预处理器修改原始的 C 程序，展开宏定义。生成的文件后缀为 hello.i。
* 编译阶段。 编译器转换文本文件为 hello.i 到包含汇编语言程序的文本文件 hello.s。
* 汇编阶段。汇编器转换 hello.s为机器语言指令，储存结果在 hello.o 中。这个文件是二进制文件。
  使用文件编辑打开是乱码。
* 链接阶段。一些包含程序中用到的预编译文件被链接器合并到结果中，生成最后的可执行文件 hello。

### 理解计算机系统工作的好处

* 优化程序性能。现代编译器能生成很好的代码，作为编程者，一般不需要知道内部工作的细节。
  但是为了写出更好的代码，我们需要了解一些机器级语言的知识。
* 理解链接错误。在以往的经验中，最常出现错误的就是链接阶段。
* 避免安全漏洞。

### 处理器处理和解释储存在内存中指令

在 Unix 系统中运行可执行文件：

```bash
shell>./hello
hello, world
shall>
```

shell 是一个命令行解释器，

#### 系统的硬件组织
* 桥。在系统中运行是通过一个电子导管集合，叫做桥，它在组件之间的前和后运行信息。
  桥被设计为传送固定大小块的比特叫做 words（字长）。4bytes=32位，8bytes=64位。
* I/O设备。输入和输出设备是系统与外部世界的连接。键盘、鼠标属于输入。显示器等属于输出。
  每一个I/O 设备通过一个控制器或适配器被连接到 I/O 桥上。
* 主存。 当程序运行时，持有程序和数据的临时存储设备。 
  DRAM（动态随机存储单元--dynamic random access devices）集合组成。
  逻辑上，主存被组织为线性比特数组，每一个元素都有唯一的地址。地址开始是0。
* 处理器。 central processing unit(CPU)、或简称为处理器是，是指靠存储在主存中指令的引擎。
  它的核心是一个字长的储存设备（或寄存器）叫做程序计数器（PC-program counter）。围绕主存、寄存器和算术逻辑单元有几个简单的操作：
  * Load（加载）：复制一个字节或字长从主存到寄存器，覆盖寄存器的值。
  * Store（储存）：从寄存器复制一个字节或字长到主存的一个位置上，覆盖那个位置上的值。
  * Oprate（操作）：从ALU（算术逻辑单元）复制两个寄存器的内容，在两个字长上执行算术操作，并且存储结果到一个寄存器中，覆盖这个寄存器的内容。
  * Jump（跳转）：从指令中挑出一个字长并且复制进程序计数器(PC)，覆盖PC的值。

#### 运行 hello 程序

当你输入./hello 时，shell 程序读取每一个到寄存器，然后储存到内存中。我们敲击 enter 时，shell 知道我们已经完成了命令输入。shell 通过一系列从磁盘到主存的复制代码和数据的指令加载可执行文件 hello。使用 direct memory access (DMA)，数据直接从磁盘到主存不用通过处理器。一旦代码和数据被加载到主存中，处理器开始执行hello 程序的 main 程序中的机器指令，这些指令复制在 hello, world\n 字符中中的字节从内存到寄存器，然后到显示设备。

### 缓存问题

系统花费大量的时间移动信息从一个地方到另一个地方。机器指令一开始在磁盘，然后被复制到主存，当处理器运行程序时，指令从主存到处理器，相似的，数据从磁盘到就主存然后到显示设备。从程序员角度来说复制是比真正程序执行要慢的。系统设计的目标是让这些复制操作尽可能的快。

因为物理定律，大的存储比小的存储慢。快的存储比慢的储存贵。

系统设计包括处理器和内存之间的比较小的更快的cache memories。 

### 操作系统管理硬件

回到 hello 的例子，当shell 加载和运行 hello 时，当hello 打印出信息时，程序没处理键盘、显示、磁盘或主存。当然它们依赖通过我操作系统提供的服务。我们可以想象操作系统是在应用程序和硬件之间的软件层。

操作系统有两个主要的目地:(1)保护硬件不被失控的程序滥用和(2)为复杂广泛的不同硬件提供统一的简单的方法。操作系统实现这两个目标是基本的抽象：进程，虚拟内存和文件。文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O设备的抽象，而进程是对处理器、主存和I/O设备的抽象。

#### 进程

当程序运行在现代操作系统上时，操作系统提供了程序是唯一运行在系统上的假象。程序看上去有额外的处理器、主存和I/O设备使用。处理器看起来是在程序程序一个接着一个的执行指令，没有中断。并且代码和程序的数据看起来是系统内存中的唯一对象。这种幻觉是一种运行的概念，一个计算机科学中最重要和最成功的主意。

进程是操作系统对运行程序的抽象。多个进程能同时的运行在一样的系统上，并且每一个进程看起来有额外的硬件使用。通过并发，我们了解到一个进程的指令和另一个进程的指令是交替进行的。在大多数系统中CPU运行有多个进程，传统的系统在一个时间点仅仅只能执行一个程序，多核处理器可能同时执行多个程序。单核CPU能看起来像同时执行多个进程通过处理器在它们之间切换。操作系统的这个机制叫做 **上下文切换**。

操作系统能保持跟换所有进程运行需要的状态信息。这个状态叫做 **上下文**，包含像PC(程序计数器)的当前值，寄存器，和主存的内容。在任意一个时间点一个单核心处理器只能走得一个进程。当操作系统决定从当前进程转换控制权到新进程时，它执行通过保存当前进程的上下文，恢复新进程的上下文，然后传递控制权到新进程来进行上下文切换。

从一个进程转换到另一个进程被操作系统内核管理。内核是操作系统代码常驻于内存的部分。当应用程序通过操作系统请求一些动作时，像读或写一个文件，它执行一个特殊的叫做 **system call**的指令，转换控制权到核心。然后核心执行请求的操作并且返回应用程序。核心并不一个分开的进程，它是系统用来管理所有进程的代码和数据结构的集合。

#### 线程

虽然我们通常认为一个进程有单一的控制流，但是在现代操作系统中一个进程实际上有多个执行单元组成，哪段和线程，它运行在进程的上下文且共享相同的代码和全局数据。线程是一个越来越重要的编程模型，因为网络服务器的并发需求，因为相比多个进程之间它在多个线程之间能容易共享数据，并且线程比进程更有效。当多个处理器可用时，多个进程也是一种使程序运行更快的方法。

#### 虚拟内存

虚拟内存是一个提供每个进程有额外的主存的幻觉的抽象。每个进程有相同的内存显示，叫做虚拟地址空间。虚拟地址空间。

虚拟地址空间有一些众所周知的部分组成，它们各有目地：

* 程序代码和数据。代码开始于所有进程的相同的固定的地址，跟着相似的全局C变量空间。代码和数据区是直接从一个可执行对象文件的上下文中初始化的。
* 堆(Heap)。代码和数据区接下是运行时堆。不像代码和数据区一旦进程开始运行大小是固定的，当C 标准库运行像 malloc 和 free 时，堆能动态的扩大或缩小。
* 共享库。靠近地址空间中间的荡然无存是持有代码和数据共享库的地方，像C 标准库和数据库。
* 栈。在用户地址空间的顶部是用户栈，它是编程器用户实现函数调用的，就像堆，用户栈在程序执行时也能动态的扩大或缩小。实际中，每次我们调用函数时，栈生长。每次我们从函数返回时，它缩小。
* 核心虚拟内存。地址空间的顶部区域是保留核心的。应用程序不能在这个区域读取或写入内容或直接调用下定义在核心代码上的函数。它们必须调用核心去执行这些操作。

#### 文件

文件是字节序列。每个E/O设备、包括磁盘、键盘、显示器甚至网络都被模型化为文件。