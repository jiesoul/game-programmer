## 链接

链接是一个收集和混合多块代码和数据到单一文件的过程，这个过程可被加载到内存并且执行。现代操作系统链接通过链接器自动执行。

链接器在软件开发中饰演一个重要的角色，因为它能分开编译。代替组织一个巨大的应用使用一个整体的源文件，我们能分解为可修改和分别编译的更小，更容易管理。当改变它们中的一个时，只需简单的重新编译它且重新链接到应用程序。不用重新编译其它文件。

在构建小的程序时，通过链接器链接通常是隐藏的，不被重视的。但是为什么要学习链接呢：

* 理解链接器将帮你构建巨大的程序。构建巨大程序的程序员经常会遇到链接错误，这些错误可能由找不到模块。找不到库，或不相容的库版本。除非你理解链接器怎么决定引用，库是什么，且链接器怎样使用一个库去决定引用，这些错误将令人困惑和沮丧。
* 理解链接器将帮你避免危险的编程错误。当获取符号引用时，Linux 链接器做出的决定可能会影响程序的正确性。默认情况下，错误定义多个全局变量的程序传递给链接器时没有任何警告。作为结果的程序可能出现令人困惑的运行时行为且极其难以调试。
* 理解链接将帮你理解语言范围的规则是怎样实现的。比如全局和局部变量的区别，你定义变量或函数为 static 的真实含义。
* 理解链接将帮你理解其它重要的系统概念。通过链接器产生的可执目标在重要的系统像加载或运行程序，虚拟内存，分页，工内存映射中使用关键规则。
* 理解链接将使你运用共享库。现代操作系统中使用共享库和动态链接越来越重要。

#### 编译驱动

```bash
linux> gcc -Og -o prog main.c sum.c
```

#### 静态链接

静态链接像 Linux LD 程序，一个浮动的目标文件集合和命令行程序作为输入并且生成一个全部已链接可以加载和运行的可执行目标文件作为输出。输入可重定位目标文件由多个代码和数据片段组成，每个片段都是连续的位序列。指令是在一个片段里，初始化全局变量在另一个片段，且未初始化的变量也在另一个片段里。

为了构建可执行，链接器必须执行两个任务:

* 符号解析。目标文件定义和引用符号，每个符号相当于一个函数，一个全局变量，或一个静态变量。符号解析的目地是关联每一个符号引用有准确的一个符号定义。
* 变换。编译器和汇编器生成代码和数据片段开始在地址 0。链接器变换这些片段通过关联内存位置和每个符号定义，然后修改所有这些引用指向相应的内存地址。

#### 目标文件

三种形式：

* 可重定位目标文件。包含二进制代码和数据，在编译期可混合其它可重定位目标文件去创建一个可执行目标文件。
* 可执行目标文件。包含二进制代码和数据，形式上能直接在内存复制和执行。
* 共享目标文件。可重定位目标文件的特殊类型，能被加载到内存且动态链接，在加载期或运行期。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。技术上，一个目标模块是一个位序列，且另一个目标文件是存储在磁盘文件中的目标模块。

目标文件组织为特殊目标文件格式，在系统之间变化。

#### 可重定位目标文件

ELF 可重定位目标文件使用一个 16 位序列为开头，这个序列解释字长和生成文件的字节顺序。ELF余下的头包含允许链接器分析和解释目标文件的信息。这包括 ELF 文件头的大小，目标文件类型， section header table的文件定位， section header table 中实体的大小和数量。许多部件的定位和大小也是通过  section header table，对于目标文件中的每个部分包含固定大小的实体。

ELF 头和  section header table 中间是部分本身。一个典型 ELF 可重定位目标文件包含下面的部分：

* .text 已编译程序的机器码。
* .rodata 只读数据像在 printf 声明中的格式字符串和转换声明的跳转表。
* .data 初始化的全局和静态 C 变量。局部 C 变量保持在栈的运行期且不会出现在 .data 或 .bss 部分。
* bss 未初始化的全局和静态 C 变量，任何全局或静态变量初始化为0。这个部分没有占用目标文件的真实空间；它不过是个点位符。目标文件区分初始化和未初始化格式为了效率：未初始化的变量不必使用目标文件任何真实空间。在运行时，这些变量被分配在内存中并初始化为0。
* .symtab 符号表是关于程序定义和引用的函数和全局变量的信息。事实上每个可重定位目标文件都有一个符号表在 .symtab(除非编程者使用 STRIP 命令移除它)。
* .ret.text 在 .text 部分里所有定位的列表，当链接器混合这个目标文件和其它时，可能被修改。通常任何调用外部函数或引用全局变量的指令都需要可以修改。另一方面，调用局部函数的指令不需要修改。注意可重定位信息不需要在可重定位目标文件中，且通常省略除非用户明确指示链接器去包括它。
* .ret.data 任意通过模块引用或定义的全局变量的可重定位信息。通常任意已初始化的全局变量，它的初始值是全局变量的地址或外面需要修改的已定义函数。
* .debug 调试符号表，它包含程序中定义的局部变量和类型引用的实体信息，程序中定义和引用的全局变量，和原始 C 源文件。它仅仅出现在编译器调用时使用了 -g 选项.
* .line 原始 C 源文件和在 .text 中机器码指令之间映射的行号。它仅仅出现在编译器选项为 -g 时。
* strtab 在 .symtab 和 .debug 部分中的字符串符号表，部分头中部分的名称。字符串表是以 NULL 为终止的字符序列。

### 符号和符号表

每个可重定位目标模块 m 有一个符号表，它包含关于通过 m 定义和引用的符号信息。在链接器的上下文中，有三种不同的符号：

* 通过模块 m 定义且能被其它模块引用的全局符号。全局链接器符号相当于非静态 C 函数和全局变量。
* 通过模块 m 引用但是通过其它模块定义的全局符号。这样的符号叫扩展，相当于定义在其它模块中的非静态 C 函数和全局变量。
* 通过模块 m 专门定义和引用的局部符号。这相当于静态 C 函数和使用 static 定义的局部变量。这些符号可以在模块 m 的任意位置，但是不能被其它模块引用。

了解局部链接器符号和局部程序变量的不一样是重要的。在 .symtab 中的符号表不包含任何相当于非静态程序变量的符号。它们被管理在栈的运行时，并且不是链接器感兴趣的。

有趣的是，使用 C  static 属性定义的局部程序变量不在栈上管理。代替的，对于每个定义编译器分配空间在 .data 和 .bss 中，并且在符号表中使用唯一的名字创建一个局部链接器符号。

符号表通过通过汇编器构建，使用符号导出通过编译器到汇编语言 .s 文件。

### 符号解析

链接器解析符号引用通过精确的联系每个引用与它的输入可重定位目标文件符号表中的一个符号定义。编译器只允许每个模块每个局部符号有一个定义。编译器也保证静态局部变量有快买中链接器符号，且唯一名称。

解析引用到全局符号是难办的。当编译器遇到一个不是定义在当前模块中的符号时，它假定它定义在其它模块中，生成一个链接器符号表实体，当链接器去处理的时候释放它。

针对全局符号的符号解析也是难办的，因为多个目标模块可能定义相同名称的全局符号。

#### 链接器怎样解析重复符号名称

链接器的输入是可重定位目标模块集合。这些模块的每一个都定义了符号集，一些是局部的，一些是全局的。

Linux系统使用的解析方法是在编译期，编译器导出每个全局符号到汇编器，或是 strong 或是 weak,然后汇编器隐式编码这些信息到可重定位目标文件的符号表。函数和已初始化的变量是 strong，未初始化全局符号是 weak。

对于 strong 和 weak 符号，Linux 链接器使用下面的规则区分重复符号名称：

* 多个 strong 符号使用相同的名称是不允许的
* strong 和 weak 符号有相同名称时，使用 strong 符号
* 都是 weak 时，选择任意一个

#### 链接静态库

有限范围内，我们假定链接器读取可重定位目标文件集合且链接它们在一个输出可执行文件。实际上，所有的编译系统都提供一个机制，打包相关目标模块到单一文件叫做静态库，它能应用为链接器输入。当它构建可执行输出时，链接器仅仅复制库中的被应用程序所引用的目标模块。

在链接期，链接器仅仅复制程序引用的目标模块，可减小磁盘和内存中执行的大小。另一方面应用程序员仅仅需要包括少量库文件的名称。

Linux 系统上，静态库存储在磁盘上的特殊文件格式叫做存档。存档是有联系的可重定位目标文件集合，使用一个头文件解释每个成员目标文件的大小和定位。存档文件名称标识为 .a 后缀。

创建静态库使用 AR 工具：

```bash
linux> gcc -c addvec.c multvec.c
linux> ar rcs libvector.a addvec.o multvec.o
```

要使用这个库，需要包括 libvector.a 中的头文件 vector.h，构建可执行：

```bash

```



#### 链接器怎样使用静态库去解析引用

在符号解析阶段，链接器用同样的顺序从左到右扫描可重定位目标文件和存档。在这个扫描期，链接器维持一个从可执行来的将被合并到可重定位目标文件集合 E，一个未解析符号信 U，和一个在上个输入文件定义的符号集D，开始时 E,U和D都是空：

* 对于每个命令行输入文件 f ，链接器判断 f 是目标文件还是存档。如果 f 是目标文件，链接器添加它到 E，更新 U 和 D 连接 f 中的符号定义和引用，并且处理下一个输入文件。
* 如果 f 是存档，链接器尝试匹配 U 中的未解析符号，相对于存档成员定义的符号。如果一些存档成员 m 定义了 U 中解析的引用的符号，则 m 被添加到 E 中，且链接器更新 U 和 D 去连接 M 中的符号定义和引用。这个过程一直在存档的成员目标文件中迭代，直到到达一个 U 和 D没有长时间改变的固定点。在这个点上，任何不包含在 E 中的成员目标文件被简单的放弃且链接器处理下一个输入文件。
* 如果链接器完成命令行中输入文件的扫描，而 U 是非空的，它打印一个错误且终止。否则，它在 E 中合并和重定位目标文件去构建输出可执行文件。

遗憾的是，这个算法产生一些另人困惑的链接期错误，因为库的顺序和命令行中目标文件是重要的。在命令行中如果定义符号的库出现在引用那个符号的目标文件之前，则引用将不能被解析且链接将失败。

对于库的通常规则是旋转它们在命令行的末尾。如果不同库成员独立，没有成员引用定义在另一个成员里的符号，则为放在最后可以是任意顺序。另一方面，如果库不是独立的，则它们必须排序，对于每个通过存档的成员的外部引用，至少在命令行上 s 的一个定义跟着 s 的一个引用。

如有必要库可在命令行重复。

### 重定位

一旦链接器完成符号解析的步骤，它就能精确关联代码中的符号引用到符号定义。链接器知道在它的输入目标模块中代码和数据部分的精确大小。重定位步骤合并输入模块且分配运行时地址到每一个符号：

* 重定位部分和符号定义。在这步，链接器合并所有相同类型的部分到相同类型的总计部分。然后链接器分配运行时内存地址给新总计部分，通过输入模块定义的每个部分，输入模块定义的每个符号。当这步完成时，程序中每个指令和全局变量有一个唯一的运行时内存地址。
* 在部分内部重定位符号引用。在这步，链接器修改每一个代码体和数据部分中的符号引用，因此它们能指向正确的运行时地址。

##### 可重定位实体

当汇编器生成目标模拟时，它不知道最终储存在内存中的代码和数据在哪。它也不知道任何外部定义的被模块引用的函数和全局变量。因此无论什么时候，汇编器遇到一个最终定位的对象引用是未知的，它生成重定们实体告诉链接器怎样修改引用当它合并目标文件到可执行文件时。可重定位实体代码放置在 .rel .text 里。数据放在 .rel .data 里。

ELF 定义了 32 种不同可重定位类型，许多相当神秘。我们仅仅关心两个基本的：

* R_X86_64PC32. 使用 32 位 PC-relative 地址重定位一个引用。PC-relative 地址是从程序计数器的当前运行值的偏移量。当 CPU 使用 PC-relative 寻址执行一个指令时，它通过在指令中添加编码 32 位值到当前 PC 的运行值形式化为有效地址，一直是内存中下一个指令的地址。
* R_X86_64_32. 使用 32 位绝对址重定位引用。使用绝对地址，CPU 直接使用指令中的 32 位值编码作为有效地址，不用更进一步修改。

有两个重定位类型支持 x86-64 小代码模型，假定可执行目标文件中的代码和数据的全部大小小于 2GB，因此能被 32 位 PC-relative 地址处理。小代码模型是 GCC 的默认。比 2 G大的程序可使用 -mcmodel=medium 和 -mcmodel=large 标志。

#### 可重定位符号引用

